<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 14 Jul 2024 14:45:06 GMT</lastBuildDate><item><title><![CDATA[네트워크 통신 흐름 간단히 이해하기]]></title><description><![CDATA[…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/network-communication-process/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/network-communication-process/</guid><pubDate>Sat, 13 Jul 2024 15:00:00 GMT</pubDate><content:encoded>&lt;p&gt;브라우저에서 서버로 데이터를 송출하는 과정을 그림으로 간단하게 표현하면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;scss&quot;&gt;&lt;pre class=&quot;language-scss&quot;&gt;&lt;code class=&quot;language-scss&quot;&gt;[네트워크 애플리케이션]
        |
    [소켓 API]
        |
   [네트워크 스택]
        |
   [LAN 드라이버]
        |
    [LAN 어댑터]
        |
[물리적 네트워크 매체]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;네트워크 애플리케이션&lt;/h4&gt;
&lt;p&gt;네트워크를 통해 다른 컴퓨터나 장치와 통신하거나 데이터를 주고받기위해 설계된 소프트웨어&lt;br/&gt;
&lt;strong&gt;웹 브라우저&lt;/strong&gt;, &lt;strong&gt;메일 서버&lt;/strong&gt;, &lt;strong&gt;파일 전송 애플리케이션&lt;/strong&gt; 등이 있다.&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;소켓 API&lt;/h4&gt;
&lt;p&gt;네트워크의 끝점(소켓)을 설정하고, 데이터 송수신을 관리한다. &lt;br/&gt;
소켓 API는 네트워크 애플리케이션에 포함된 한 기능이라고 볼 수 있다. &lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;네트워크 스택&lt;/h4&gt;
&lt;p&gt;운영체제에 내장된 네트워크 제어용 소프트웨어 &lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;주요 프로토콜&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;TCP: 데이터 송수신용 프로토콜. 일반적인 애플리케이션에서 사용.&lt;/li&gt;
&lt;li&gt;UDP: 데이터 송수신용 프로토콜. DNS 서버 조회 등 짧은 제어용.&lt;/li&gt;
&lt;li&gt;IP: 패킷 송수신용 프로토콜.
&lt;ul&gt;
&lt;li&gt;패킷: 데이터를 작게 나눈 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;LAN 드라이버&lt;/h4&gt;
&lt;p&gt;LAN 드라이버는 하드웨어를 제어하고 통신한다.&lt;/p&gt;
&lt;h4&gt;LAN 어댑터&lt;/h4&gt;
&lt;p&gt;물리적 네트워크 매체(케이블, 무선 네트워크)에 대해 데이터를 송수신한다.&lt;/p&gt;
&lt;p&gt;데이터가 네트워크로 전송되는 흐름을 간단하게 적어보았다. &lt;br/&gt;
더 상세한 내용은 추후에 다른 포스트로 다루어 보려고 한다. &lt;br/&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[DNS(Domain Name System)]]></title><description><![CDATA[운영체제의 네트워크 API는 도메인이 아닌 IP 주소를 사용하여 통신하기 때문에, 도메인 주소를 IP 주소로 변환하는 과정이 필요하다.
이 과정에서 DNS 서버가 사용된다. DNS 서버에 조회 메세지를 보내고 응답을 받는 클라이언트를 "DNS…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/dns-server/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/dns-server/</guid><pubDate>Sat, 06 Jul 2024 19:00:00 GMT</pubDate><content:encoded>&lt;p&gt;운영체제의 네트워크 API는 도메인이 아닌 IP 주소를 사용하여 통신하기 때문에, 도메인 주소를 IP 주소로 변환하는 과정이 필요하다.&lt;br/&gt;
이 과정에서 &lt;strong&gt;DNS 서버&lt;/strong&gt;가 사용된다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;DNS 서버에 조회 메세지를 보내고 응답을 받는 클라이언트를 &quot;&lt;strong&gt;DNS 리졸버&lt;/strong&gt;&quot;라고 한다. &lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 리졸버는 사용자가 입력한 도메인을 기반으로 &lt;strong&gt;DNS 쿼리&lt;/strong&gt;를 만든다.&lt;/li&gt;
&lt;li&gt;DNS 쿼리를 전송하기 위해 &lt;strong&gt;네트워크 스택&lt;/strong&gt;을 호출한다.&lt;/li&gt;
&lt;li&gt;네트워크 스택이 DNS 쿼리를 DNS 서버에 &lt;strong&gt;전송&lt;/strong&gt;하고 &lt;strong&gt;응답&lt;/strong&gt;을 받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 과정이 DNS 서버의 통신 과정을 간략하게 설명한 것이다.&lt;/p&gt;
&lt;p&gt;그렇다면 &lt;strong&gt;DNS 쿼리&lt;/strong&gt;에는 무슨 내용이 들어갈까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;이름&lt;/strong&gt; : 도메인의 이름&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;레코드 타입&lt;/strong&gt; : 요청하는 정보의 유형
&lt;ul&gt;
&lt;li&gt;A 타입(IP 주소)&lt;/li&gt;
&lt;li&gt;MX 타입(메일 서버)&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;클래스&lt;/strong&gt;: IN 클래스(인터넷)
&lt;ul&gt;
&lt;li&gt;인터넷 이외의 네트워크는 거의 소멸되었기 때문에 항상 IN을 쓴다고 생각해도 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS 쿼리를 받은 DNS 서버는 일치하는 정보를 찾고 해당하는 &lt;strong&gt;리소스 레코드&lt;/strong&gt;를 응답한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리소스 레코드 : 도메인 정보를 담고있는 주소록의 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MX 타입&lt;/strong&gt; &lt;br/&gt;
MX 타입(메일 서버 타입)은 도메인과 우선 순위가 함께 저장이 되어있다.&lt;br/&gt;
(숫자가 낮을 수록 우선 순위가 높다.)&lt;br/&gt;
DNS 쿼리를 받으면 MX 리소스 레코드의 &lt;strong&gt;목록&lt;/strong&gt;을 보낸다. &lt;br/&gt;
DNS 리졸버는 우선순위가 높은 메일 서버 선택 후 추가 DNS 쿼리를 보내게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;하지만 현실의 인터넷에서는 막대한 수의 서버가 존재한다.&lt;br/&gt;
1대의 DNS 서버에 모든 도메인을 등록하는 것은 역시 불가능하다.&lt;br/&gt;
이를 분산시켜서 다수의 DNS 서버에 등록하고 서로 연대하여 정보를 찾는다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;그전에 도메인에 대해 간단히 이해해보자.&lt;/p&gt;
&lt;h4&gt;도메인&lt;/h4&gt;
&lt;p&gt;인터넷에서 네트워크 서비스를 식별하고 접근하기 위해 사용하는 고유의 이름.&lt;br/&gt;
&lt;strong&gt;점(.)으로 구분된 계층구조를 가진다.&lt;/strong&gt;&lt;br/&gt;
예를 들어, &lt;strong&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/strong&gt; 는 아래와 같은 계층구조로 구분할 수 있다.&lt;br/&gt;
&lt;strong&gt;www&lt;/strong&gt; - 하위 도메인, &lt;strong&gt;example&lt;/strong&gt; - 2차 도메인(SLD), &lt;strong&gt;com&lt;/strong&gt; - 최상위 도메인(TLD)&lt;/p&gt;
&lt;p&gt;DNS 서버는 수만대나 있기 때문에 모든 서버를 다 찾는 건 현실적으로 불가능하다.&lt;br/&gt;
이 때 도메인의 계층 구조를 활용할 수 있다.&lt;/p&gt;
&lt;p&gt;하위 도메인을 담당하는 DNS 서버의 IP 주소를 상위 DNS 서버에 등록하는 것이다.&lt;br/&gt;
그리고 &lt;code class=&quot;language-text&quot;&gt;kr&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;com&lt;/code&gt;과 같은 최상위 도메인 위에 &lt;strong&gt;루트 도메인&lt;/strong&gt;을 두고, &lt;br/&gt;
마지막으로 &lt;strong&gt;루트 도메인의 DNS 서버를 인터넷이 존재하는 DNS 서버에 전부 등록을 하면 된다&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;이로써 루트 도메인에서부터 차례로 아래쪽으로 거슬러 내려가며 원하는 DNS 서버를 찾을 수 있게 되었다!&lt;/p&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;의 IP 주소를 묻는 과정에 대해 예시를 들어보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 가까운 DNS 서버(로컬 DNS 서버)에 &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;의 IP 주소를 묻는다.&lt;/li&gt;
&lt;li&gt;로컬 DNS 서버는 루트 DNS 서버에게 &quot;.&quot;(루트) 도메인에 대한 쿼리를 보냅니다.&lt;/li&gt;
&lt;li&gt;루트 DNS 서버는 최상위 도메인(.com)의 DNS 서버 주소를 반환한다.&lt;/li&gt;
&lt;li&gt;로컬 DNS 서버는 &quot;.com&quot; 도메인의 DNS 서버에게 &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;의 IP 주소를 묻는다.&lt;/li&gt;
&lt;li&gt;&quot;.com&quot; 도메인의 DNS 서버는 &quot;example.com&quot; 도메인의 DNS 서버 주소를 반환한다.&lt;/li&gt;
&lt;li&gt;로컬 DNS 서버는 &quot;example.com&quot; 도메인의 DNS 서버에게 &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;의 IP 주소를 묻는다.&lt;/li&gt;
&lt;li&gt;&quot;example.com&quot; 도메인의 DNS 서버는 &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;의 IP 주소를 반환한다.&lt;/li&gt;
&lt;li&gt;로컬 DNS 서버는 클라이언트에게 &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;의 IP 주소를 전달한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;사실 DNS 서버는 &lt;strong&gt;캐시&lt;/strong&gt;를 사용하기 때문에 실제 동작은 위의 예시와 차이가 있을 수 있다.&lt;br/&gt;
&lt;strong&gt;DNS 서버는 한 번 조사한 이름을 캐시에 기록하고, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 위치부터 찾기 시작한다.&lt;/strong&gt; &lt;br/&gt;
하지만, 캐시에 저장된 후 정보가 변경되는 일도 있으므로 일정기간이 지나면 삭제한다.&lt;br/&gt;
또한 클라이언트에게 IP 주소를 전달할 때 캐시에서 가져온 정보인지 DNS 서버에서 가져온 정보인지 알려준다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[IP 주소]]></title><description><![CDATA[브라우저는 URL을 해독하여 HTTP 메세지를 만든다. 
하지만 네트워크에 메세지를 보내는 기능이 없기 때문에 이 요청을 운영체제에 의뢰한다.
운영체제의 네트워크 API는 도메인이 아닌 IP 주소를 사용하여 통신한다.  그럼 IP…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/ip-address/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/ip-address/</guid><pubDate>Sat, 06 Jul 2024 18:00:00 GMT</pubDate><content:encoded>&lt;p&gt;브라우저는 URL을 해독하여 HTTP 메세지를 만든다. &lt;br/&gt;
하지만 네트워크에 메세지를 보내는 기능이 없기 때문에 이 요청을 운영체제에 의뢰한다.&lt;br/&gt;
운영체제의 네트워크 API는 도메인이 아닌 &lt;strong&gt;IP 주소&lt;/strong&gt;를 사용하여 통신한다. &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;그럼 &lt;strong&gt;IP 주소&lt;/strong&gt;는 무엇이고 어떻게 구성될까?&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;IP 주소는 &lt;strong&gt;네트워크 번호&lt;/strong&gt;와 &lt;strong&gt;호스트 번호&lt;/strong&gt;의 조합으로 이루어져있다.&lt;/p&gt;
&lt;h5&gt;네트워크 번호&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;서브넷의 주소
&lt;ul&gt;
&lt;li&gt;서브넷 : 동일한 네트워크 주소를 공유하는 기기들의 그룹. 허브 or 스위치에 연결되어 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;호스트 번호&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;동일한 서브넷 내에서 개별 기기를 식별하는 부분&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;서브넷은 &lt;strong&gt;라우터&lt;/strong&gt;에 연결되어있다.&lt;br/&gt;
여러 서브넷이 라우터에 연결되어 전체 네트워크를 구성한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IP 주소는 32비트로 구성되어 있고 8비트씩 점(.)으로 구분한다.&lt;br/&gt;
IP 주소는 네트워크 번호와 호스트 번호가 합쳐서 32비트여야 한다는 규칙만 존재하므로 IP 주소만 보면 어디가 네트워크 번호와 호스트 번호인지 구분할 수 없다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;따라서 &lt;strong&gt;&quot;서브넷 마스크&quot;&lt;/strong&gt; 를 사용하여 구분한다.&lt;/p&gt;
&lt;p&gt;서브넷 마스크는 다음 두 가지 방법으로 표기할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/255.255.255.0
&lt;ul&gt;
&lt;li&gt;eg) 10.11.12.13/255.255.255.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;/24
&lt;ul&gt;
&lt;li&gt;eg) 10.11.12.13/24&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 두 표기 다 &lt;code class=&quot;language-text&quot;&gt;11111111.11111111.11111111.00000000&lt;/code&gt;와 같은 의미이다.&lt;br/&gt;
서브넷 마스크가 1인 부분은 네트워크 번호, 0인 부분은 호스트 번호.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;10.11.12.**0**/24&lt;/code&gt;와 같이 호스트 번호의 비트값이 전부 0이면 서브넷 그 자체를 의미하고, &lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;10.11.12.**255**/24&lt;/code&gt;와 같이 전부 1이면 서브넷에 연결된 모든 기기에 패킷을 보내는 브로드캐스트를 의미한다. &lt;br/&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP 요청과 응답]]></title><description><![CDATA[브라우저는 입력받은 URL을 해독한 후 HTTP를 사용하여 웹 서버에 엑세스 한다.
그런데, HTTP가 뭐지? HTTP…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/http/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/http/</guid><pubDate>Sat, 06 Jul 2024 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;브라우저는 입력받은 URL을 해독한 후 HTTP를 사용하여 웹 서버에 엑세스 한다.&lt;br/&gt;
그런데, &lt;strong&gt;HTTP&lt;/strong&gt;가 뭐지?&lt;/p&gt;
&lt;h3&gt;HTTP&lt;/h3&gt;
&lt;p&gt;클라이언트(웹 브라우저)와 서버(웹 서버) 간의 데이터를 주고받기 위한 프로토콜.&lt;br/&gt;
인터넷 상에서 웹 페이지를 전달하는 가장 기본적인 통신규약&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트는 HTTP 요청을 보내고 서버는 HTTP 응답을 반환한다.&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;HTTP 요청(HTTP Request)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;요청 줄(Request Line): &lt;strong&gt;메서드&lt;/strong&gt;, URL, HTTP 버전 포함&lt;/li&gt;
&lt;li&gt;헤더(Header)&lt;/li&gt;
&lt;li&gt;바디(Body): 선택 사항&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;주요 메서드&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;li&gt;PUT&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;HTTP 응답(HTTP Response)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;상태 줄(Status Line): HTTP 버전, &lt;strong&gt;상태 코드(Status Code)&lt;/strong&gt;, 상태 메세지&lt;/li&gt;
&lt;li&gt;헤더(Header)&lt;/li&gt;
&lt;li&gt;바디(Body)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;주요 상태 코드&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;200 OK: 요청이 성공적으로 처리되었음&lt;/li&gt;
&lt;li&gt;400 Bad Request: 잘못된 요청임&lt;/li&gt;
&lt;li&gt;401 Unauthorized: 인증이 필요함&lt;/li&gt;
&lt;li&gt;404 Not Found: 요청한 리소스를 찾을 수 없음&lt;/li&gt;
&lt;li&gt;500 Internal Server Error: 서버 오류가 발생했음&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;주요 헤더 필드&lt;/h4&gt;
&lt;h5&gt;제너럴 헤더&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Date: 작성된 날짜&lt;/li&gt;
&lt;li&gt;Connection: 연결 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;리퀘스트 헤더&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Accept: 클라이언트가 수신할 수 있는 콘텐츠 타입&lt;/li&gt;
&lt;li&gt;User-Agent: 요청을 보내는 클라이언트(브라우저)의 정보&lt;/li&gt;
&lt;li&gt;Host: 요청하는 서버의 호스트 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;응답 헤더&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Server: 서버의 소프트웨어와 버전 정보를 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;엔티티 헤더&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Content-Type: 응답 본문의 데이터 타입&lt;/li&gt;
&lt;li&gt;Content-Length: 응답 본문의 길이를 바이트 단위로 나타냄&lt;/li&gt;
&lt;li&gt;Expires: 캐시된 응답의 만료 날짜와 시간을 나타냄&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Content-Type: text/html&lt;/strong&gt; 일 때&lt;/p&gt;
&lt;p&gt;HTML 문서 안에 포함된 이미지나 영상 등의 리소스들은 필요에 따라 추가적인 HTTP 요청을 통해 받아오게 된다.&lt;br/&gt;
이미지나 다른 리소스가 별도의 URL로 제공되고 있을 경우, 클라이언트는 해당 리소스에 대해 별도의 HTTP 요청을 보낸다.&lt;br/&gt;
예를 들어, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img src=&quot;image.jpg&quot;&gt;&lt;/code&gt;와 같은 경우 이미지 파일 &apos;image.jpg&apos;를 따로 요청하여 받아옴.&lt;br/&gt;
만약, 문서 안에 세 개의 리소스가 포함되어 있다면 HTTP 요청을 총 4번 보내게 되는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[URL과 URL 구조]]></title><description><![CDATA[사용자가 브라우저 주소창에 URL을 입력하면 어떤 일이 일어날까?
그 전에 URL과 URL 구조에 대해 알아보자. URL URL…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/url/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/url/</guid><pubDate>Sat, 06 Jul 2024 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;사용자가 브라우저 주소창에 URL을 입력하면 어떤 일이 일어날까?&lt;br/&gt;
그 전에 &lt;strong&gt;URL&lt;/strong&gt;과 &lt;strong&gt;URL 구조&lt;/strong&gt;에 대해 알아보자.&lt;/p&gt;
&lt;h3&gt;URL&lt;/h3&gt;
&lt;p&gt;URL은 간단하게 말해 리소스가 저장되어 있는 위치를 지정하는 주소를 말한다.&lt;br/&gt;
주로 &lt;code class=&quot;language-text&quot;&gt;http:&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;https:&lt;/code&gt;를 많이 보게 되지만 그 외에도 &lt;code class=&quot;language-text&quot;&gt;ftp:&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;file:&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;mailto:&lt;/code&gt; 등 다양하다.&lt;br/&gt;
이것의 이름을 &lt;strong&gt;URL 스킴(URL Scheme)&lt;/strong&gt; 이라고 하는데 리소스에 접근하는 방식을 정의한 것이다. &lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹이라면 &lt;code class=&quot;language-text&quot;&gt;http:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;FTP 서버라면 &lt;code class=&quot;language-text&quot;&gt;ftp:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;파일 시스템이라면 &lt;code class=&quot;language-text&quot;&gt;file:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이메일이라면 &lt;code class=&quot;language-text&quot;&gt;mailto:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
URL을 작성하는 방법은 URL 스킴에 따라 다르다.&lt;br/&gt;
도메인 명/파일 경로/메일 주소 등이 들어갈 수도 있고, 때에 따라 사용자명, 비밀번호, 포트번호 등도 사용한다.&lt;br/&gt;
eg) `https://www.example.com:8080/path/to/resource`, &lt;br/&gt; `ftp://username:password@ftp.example.com/public/file.txt`
&lt;p&gt;&lt;br/&gt;그 다음 &lt;strong&gt;브라우저&lt;/strong&gt;는 입력된 URL을 &lt;strong&gt;해독&lt;/strong&gt;한다.&lt;/p&gt;
&lt;p&gt;해독하는 과정의 첫번째는 바로 URL 파싱이다.&lt;br/&gt;
URL은 다음과 같은 요소로 분해된다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;➀ &lt;strong&gt;URL 스킴&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;http:&lt;/code&gt;&lt;br/&gt;
➁ &lt;strong&gt;호스트명&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;www.example.com&lt;/code&gt;&lt;br/&gt;
➂ &lt;strong&gt;포트번호&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;8080&lt;/code&gt; (지정된 경우만)&lt;br/&gt;
➃ &lt;strong&gt;경로&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;/dir/index.html&lt;/code&gt;&lt;br/&gt;
➄ &lt;strong&gt;쿼리문자열&lt;/strong&gt;: &lt;code class=&quot;language-text&quot;&gt;tab=repositories&lt;/code&gt; (선택 사항)&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;http://www.example.com/dir/index.html&lt;/code&gt; 의 경우는 dir 디렉터리에 있는 index.html을 엑세스한다는 의미이다.&lt;br/&gt;
하지만, 모든 URL 구조가 정확한 파일 경로를 가지고 있는 건 아니다.&lt;br/&gt;&lt;br/&gt;
아래 다섯가지 예시를 보자.&lt;/p&gt;
&lt;h5&gt;➀ &lt;a href=&quot;http://www.example.com/dir/index.html&quot;&gt;www.example.com/dir/index.html&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/strong&gt; 서버에 있는 &lt;strong&gt;/dir&lt;/strong&gt; 디렉터리 내 &lt;strong&gt;index.html&lt;/strong&gt; 파일을 요청&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;➁ &lt;a href=&quot;http://www.example.com/dir/&quot;&gt;www.example.com/dir/&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/strong&gt; 서버에 있는 &lt;strong&gt;/dir&lt;/strong&gt; 디렉터리를 요청&lt;/li&gt;
&lt;li&gt;디렉터리 내 기본 파일 (서버에서 설정한 파일, 보통 index.html)을 반환&lt;/li&gt;
&lt;li&gt;기본 파일이 없는 경우 디렉터리 목록을 반환&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;➂ &lt;a href=&quot;http://www.example.com/&quot;&gt;www.example.com/&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/strong&gt; 서버에 있는 루트 디렉터리를 요청&lt;/li&gt;
&lt;li&gt;루트 디렉터리 내 기본 파일 (index.html, index.php 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;➃ &lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;➂과 같이 루트 디렉터리 요청&lt;/li&gt;
&lt;li&gt;&apos;/&apos;(슬래시)가 생략되었지만 브라우저와 서버에서 보완함&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;➄ &lt;a href=&quot;http://www.example.com/whatisthis&quot;&gt;www.example.com/whatisthis&lt;/a&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/strong&gt; 서버에 있는 whatisthis라는 리소스 요청&lt;/li&gt;
&lt;li&gt;파일일수도 디렉터리일수도 있음&lt;/li&gt;
&lt;li&gt;whatisthis라는 파일이 존재 시 파일 반환, 디렉터리가 있으면 디렉터리 반환(둘 다 존재할 수는 없다.)&lt;/li&gt;
&lt;li&gt;둘 다 존재하지 않는다면 404 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;URL을 해독한 후 브라우저는 HTTP를 사용하여 웹 서버에 엑세스 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby로 개발 블로그 시작!]]></title><description><![CDATA[👷‍♀️ 새 단장 중! 불편을 드려 죄송합니다.]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/start-tech-blog-with-gatsby/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/start-tech-blog-with-gatsby/</guid><pubDate>Thu, 04 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;👷‍♀️ 새 단장 중! 불편을 드려 죄송합니다.&lt;/h3&gt;</content:encoded></item></channel></rss>