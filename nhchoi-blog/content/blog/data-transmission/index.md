---
title: 데이터를 송수신하기
date: "2024-07-19T00:00:00"
description: "클라이언트-서버 통신의 흐름 - 2"
tags: ["Network"]
---


클라이언트와 서버의 통신 흐름은 다음과 같다.
1. **소켓을 생성한다.**
2. **서버에 접속한다.**
3. **데이터를 송수신한다.**
4. **연결을 끊고 소켓을 말소한다.**

이 포스트에서는 **데이터 송수신**과 **연결 종료**에 대해 다룰 예정이다.
앞선 소켓 생성과 서버 접속에 관한 내용은 [여기](https://nahyunie.github.io/create-socket/)에서 볼 수 있다.


### 데이터를 송수신한다.
애플리케이션이 **write() 함수**를 호출하여 네트워크 스택에게 데이터를 넘겨주는 것으로 이 과정이 시작된다. <br/>
네트워크 스택은 데이터를 서버로 바로 전송하는 것이 아니라 내부에 있는 **데이터 버퍼에 모아놨다가 전송한다.** <br/>
상황에 따라 어떤 애플리케이션은 데이터를 한 번에 전달할 수도 있고, 또 다른 애플리케이션은 1바이트씩 전달할 수도 있다.<br/>
많은 양의 패킷을 서버로 전송하게 되면 효율성이 저하되므로 데이터를 모아놓고 적당한 시기에 서버로 전송하는 것이다.<br/>

그럼 **적당한 시기**란 과연 언제일까?
데이터 전송 여부를 결정하는 판단 요소는 크게 두 가지가 있다.

#### 데이터의 크기
네트워크 스택은 **MTU(Maximum Transmission Unit)** 이라는 매개변수를 보고 판단한다.<br/>
MTU는 패킷 한 개로 운반할 수 있는 데이터의 길이이다.<br/>
그리고 MTU에서 헤더를 제외한 데이터의 길이를 나타낸 것이 **MSS(Maximum Segment Size)** 이다.<br/>
애플리케이션에서 받은 데이터가 MSS 길이에 다다르면 패킷을 서버에게 전송한다.

#### 타이밍
송신이 느린 애플리케이션에서 MSS 길이에 다다를 때까지 기다린다면 데이터 전송이 지연된다.<br/>
이런 경우엔 네트워크 스택 내부의 타이머가 있어 일정 시간이 지나면 패킷을 서버에게 전송한다.

>데이터의 크기를 중시한다면 패킷 길이가 길어져서 효율성은 높아지지만 송신이 지연될 수 있고,<br/>
>타이밍을 중시한다면 지연은 적어지지만 효율성이 낮아지게 된다.<br/>
>
>어떤 요소를 중요하게 생각할지는 네트워크 스택을 만드는 개발자에게 달려있다. <br/>
>따라서 OS 종류와 버전에 따라 차이가 있을 수 있다. <br/>

만약 애플리케이션으로부터 받은 데이터가 큰 경우에는 이를 쪼개는 과정을 거친다.<br/>
MSS 크기에 맞춰서 분할하고 하나씩 패킷에 넣어 맨 앞에 TCP 헤더 정보를 부가하여 서버로 전송한다.<br/>

TCP는 송신한 데이터가 서버에게 잘 도착했는지 확인하고, 도착하지 않았으면 재전송한다. <br/>

#### 시퀀스 번호
데이터를 분할할 때 각 패킷이 원본 데이터에서 몇 번째 바이트에 해당하는지 나타내는 번호<br/>
서버는 수신 받은 패킷의 TCP 헤더에 적힌 시퀀스 번호와 데이터 길이를 토대로 전체 데이터에서 어떤 범위에 해당하는지 계산한다. <br/>
서버는 몇 번째 바이트까지 받았는지 ACK 번호에 기록하여 클라이언트에게 응답한다.<br/>
```
클라이언트 → 서버: [시퀀스 번호=1000, 데이터 길이=20]
서버 → 클라이언트: [ACK=1020]
```
`ACK=1020`는 1020번 바이트부터의 데이터를 기대하고 있음을 의미한다.<br/>

>현실에선 시퀀스 번호는 1부터 시작하는 것이 아니라 난수로 시작한다.<br/>
> (시퀀스 번호를 예측하여 공격하는 것을 막기 위함) <br/>
> 3-way handshake로 TCP 연결 설정을 할 때 클라이언트와 서버는 서로 시퀀스 번호의 초기값을 주고 받는다.

클라이언트가 서버에게 데이터를 송신하고 응답값이 돌아오지 않으면<br/>
클라이언트는 한없이 다시 보내는 것이 아니라 수 번 보낸 후 가망이 없는 것으로 판단되면,<br/>
데이터 통신을 강제 종료하고 애플리케이션에 오류가 발생했음을 통지한다. <br/>

#### 타임아웃
서버로부터 ACK 값이 돌아오는 것을 기다리는 시간을 **타임아웃 값**이라고 한다. <br/>
타임아웃 값을 설정하는 것은 간단하지 않다.<br/>
서버에 따라 편차가 크기 때문에 모든 환경에 대해 일정한 값으로 설정하는 것은 적절하지 않다.<br/>
**TCP는 ACK가 돌아오는 시간을 항상 기록해두고 지연되면 대기시간을 늘리고, 빠르게 돌아오면 대기시간을 줄인다.**<br/>

#### 윈도우 제어
클라이언트는 패킷을 보내고 ACK 번호를 받을 때까지 대기하고 있지 않는다. <br/>
**윈도우 제어**라는 방식을 사용하여 연속해서 여러 개의 패킷을 서버에게 전송한다. <br/>

그러다보면, 데이터를 받는 측의 능력보다 과도하게 전송하는 상황이 생길 수 있다.<br/>
이를 방지하기 위해 수신 측은 송신 측에게 받을 수 있는 데이터의 양을 알려준다. <br/>
TCP 헤더의 **윈도우 사이즈** 가 바로 이 내용이다.

그럼 서버는 클라이언트에게 윈도우 사이즈도 보내야 하고 ACK 번호도 보내야 하는데,<br/>
위 두 값은 어떤 타이밍에 클라이언트에게 전송이 될까?<br/>

1. 윈도우 사이즈
   - 윈도우 사이즈는 수신 버퍼에 빈 영역이 늘어났을 때 통지된다.
2. ACK 번호
   - ACK 번호는 보통 데이터를 받자마자 바로 통지한다.

두 값을 서로 다른 패킷에 넣어 보내게 되면 효율성이 저하된다.<br/>
따라서, 클라이언트는 바로 보내지 않고 기다렸다가 다음 동작이 일어나면 두 값을 한 개의 패킷에 넣어서 전송한다.<br/>
ACK 번호 통지가 연속 발생했을 때나 윈도우 통지가 연속 발생했을 때도 마친가지로 하나의 패킷에 묶어서 전송하게 된다.<br/>

이로써 HTTP 리퀘스트 메세지를 보내는 과정은 끝난다.<br/>

서버는 응답 메세지를 보낸 후 연결 끊기 단계에 돌입한다.<br/>
서버 측 애플리케이션에서 **close()** 함수를 호출하면 네트워크 스택은 TCP 헤더의 `FIN` 비트를 1로 설정한 후 클라이언트에게 보낸다.<br/>

클라이언트는 `FIN` 패킷을 수신하고, 이를 확인했다는 의미로 ACK 번호를 서버에게 통지한다.<br/>
그리곤 **read()** 함수를 호출하여 서버가 보낸 응답 데이터를 받는다. <br/>
데이터를 전부 읽어 들였으면 클라이언트 측 애플리케이션도 close() 함수를 호출한다.<br/>
네트워크 스택은 TCP 헤더의 `FIN` 비트를 1로 설정한 후 서버에게 보낸다.
서버도 클라이언트의 `FIN` 패킷을 수신하고, 이를 확인했다는 의미로 ACK 번호를 클라이언트에게 통지함으로서 대화가 종료된다.

대화는 끝이 났지만 소켓은 일정 시간 동안 오동작에 대비하기 위해 열려있는 상태로 대기한다.



<br/><br/>









