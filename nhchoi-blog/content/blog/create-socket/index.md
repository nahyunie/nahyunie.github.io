---
title: 소켓을 생성하고 서버에 연결하기
date: "2024-07-15T01:00:00"
description: "클라이언트-서버 통신의 흐름 - 1"
tags: ["Network"]
---

클라이언트와 서버의 통신 흐름은 다음과 같다.
1. **소켓을 생성한다.**
2. **서버에 접속한다.**
3. **데이터를 송수신한다.**
4. **연결을 끊고 소켓을 말소한다.**

이 포스트에서는 **소켓 생성**과 **서버 접속**에 대해 다룰 예정이다.

### 소켓을 생성한다.
#### 소켓
**소켓**은 네트워크 통신의 끝점을 나타내는 추상적인 개념이다.<br/>
소켓에는 IP 주소, 포트 번호, 연결 상태 정보 등의 제어 정보가 포함되어 있으며, 이 정보들이 소켓의 실체라고 볼 수 있다.

**"소켓을 만든다."** 라는 말은 간단히 말하자면 **socket()** 함수를 호출한다는 의미이다.<br/>
더 자세히는 소켓을 위한 데이터 구조를 생성하고 필요한 메모리를 할당하는 행위라고 말할 수 있다.

socket() 함수를 호출하면 네트워크 스택은 애플리케이션에게 **디스크립터**를 반환하게 되는데, <br/>
디스크립터는 각 소켓을 식별하기 위한 번호표같은 정보이다. <br/>
애플리케이션은 추후에 디스크립터를 통해 데이터 송수신과 같은 작업을 수행한다.

### 서버에 접속한다.
**"서버에 접속한다."** 라는 말은 애플리케이션이 **connect()** 함수를 호출한다는 말과 같다.<br/>
함수의 인자로 디스크립터, IP 주소, 포트 번호 등을 서버에게 넘겨주고<br/>
성공값을 반환받으면 클라이언트와 서버간의 연결이 정상적으로 완료된 것이다.<br/>

위 과정을 조금 더 자세히 설명하기 위해 TCP 헤더에 대해 알아볼 필요가 있다. 

#### TCP 헤더
클라이언트와 서버는 패킷 단위로 데이터를 주고 받는데, 모든 패킷에는 TCP 헤더 정보가 포함이 되어있다. <br/>
TCP 헤더를 통해 데이터 전송을 관리하고 데이터의 순서를 보장하는 등 TCP의 안정적인 통신을 위해 중요한 역할을 수행한다.<br/>

```mathematica
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Source Port          |       Destination Port        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Acknowledgment Number                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Data  |Rese-|     Flags      |            Window             |
  | Offset | rved|                 |            Size              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           Checksum            |        Urgent Pointer         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Options (if any)                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Padding (if any)                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

TCP 헤더를 구성하는 필드들은 아래와 같다.

1. **Source Port(16비트)**: 출발지 포트 번호
2. **Destination Port(16비트)**: 목적지 포트 번호
3. **Sequence Number(32비트)**: 해당 패킷의 데이터가 송신 데이터의 몇 번째 바이트에 해당하는지 나타내는 번호
4. **Acknowledgment Number(32비트)**: 데이터가 몇 바이트까지 목적지에 도착했는지 나타내는 번호 
5. **Data Offset(4비트)**: TCP 헤더의 길이
6. **Reserved(3비트)**: 예약 번호. (사용하지 않음)
7. **Flags(9비트)**: 컨트롤 비트. 각 비트가 특정 제어 정보를 나타냄. 
   - URG (Urgent): 긴급 포인터 필드의 값이 유효함을 나타냄 
   - ACK (Acknowledgment): 확인 응답 번호 필드의 값이 유효함을 나타냄 
   - PSH (Push): flush 동작을 통해 송신된 데이터임을 나타냄 
   - RST (Reset): 연결을 재설정함
   - SYN (Synchronize): 연결 설정을 시작
   - FIN (Finish): 연결 종료를 요청
8. **Window Size(16비트)**: 수신자가 한 번에 받을 수 있는 데이터의 양
9. **Checksum(16비트)**: 오류 검출을 위한 값
10. **Urgent Pointer(16비트)**: 긴급하게 처리해야 할 데이터의 위치를 나타냄
11. **Option**: 다양한 TCP 옵션을 포함할 수 있으며 가변길이임
12. **Padding**: TCP 헤더의 길이를 32비트 단위로 맞추기 위해 사용되는 필드로 가변길이임


TCP 헤더에 대해 설명했으니 서버 접속에 대해 마저 얘기해보자.<br/>
connect 함수가 호출되면 해당 명령은 네트워크 스택으로 전달된다.<br/>
그리곤 서버와 연결을 위한 제어 정보를 서로 주고 받는데, 이 과정을 **3-way handshake**라고 한다.

#### 3-way handshake
```
클라이언트                                                서버
   |                                                    |
   |------  SYN (Source Port, Destination Port) ------> |
   |                                                    |
   |<--- SYN=1, ACK=1 (Source Port, Destination Port)---|
   |                                                    |
   |------  ACK (Source Port, Destination Port) ------> |
   |                                                    |

```
우선 네트워크 스택은 제어 정보를 기록한 헤더를 만든다.<br/>
출발지와 목적지의 포트 번호를 설정하고 컨트롤 비트의 **SYN 비트를 1로 설정한다**.<br/>
그리고 IP 담당 부분에 건네면 패킷 송신 동작이 실행된다. <br/>

서버가 패킷을 받으면 도착지 포트 번호에 기록된 것과 같은 포트 번호를 찾는다. <br/>
서버는 **ACK 비트와 SYN 비트를 1로 설정**히고 클라이언트에게 전송한다. <br/>

클라이언트는 SYN 비트가 1임을 확인하고 소켓에 접속 완료를 표시한다.<br/>
그리고 패킷이 정상적으로 도착했다는 것을 서버에게 알리기 위해 **ACK 비트를 1로 설정**한 헤더를 서버에게 보낸다. <br/>

이제 클라이언트와 서버의 소켓은 데이터를 송수신 할 수 있는 상태가 되었다.<br/>
이 연결은 close 함수를 호출하여 연결을 끊기 전까지 유효하다.<br/>


